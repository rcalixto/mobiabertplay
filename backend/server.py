from fastapi import FastAPI, APIRouter, HTTPException, Depends, File, UploadFile, Query
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from dotenv import load_dotenv
from starlette.middleware.cors import CORSMiddleware
from motor.motor_asyncio import AsyncIOMotorClient
from fastapi.staticfiles import StaticFiles
import os
import logging
from pathlib import Path
from pydantic import BaseModel, Field, HttpUrl
from typing import List, Optional, Dict, Any
import uuid
from datetime import datetime
from enum import Enum
import aiofiles
import shutil

ROOT_DIR = Path(__file__).parent
load_dotenv(ROOT_DIR / '.env')

# MongoDB connection
mongo_url = os.environ['MONGO_URL']
client = AsyncIOMotorClient(mongo_url)
db = client[os.environ['DB_NAME']]

# Create uploads directory
uploads_dir = ROOT_DIR / "uploads"
uploads_dir.mkdir(exist_ok=True)

# Create the main app
app = FastAPI(title="mobinabert PLAY - Plataforma de R치dios", version="1.0.0")

# Create a router with the /api prefix
api_router = APIRouter(prefix="/api")

# Mount static files for uploaded logos
app.mount("/uploads", StaticFiles(directory=str(uploads_dir)), name="uploads")

# Security
security = HTTPBearer()
ADMIN_TOKEN = "admin-radio-token-2025"

# Enums
class GeneroEnum(str, Enum):
    JORNALISMO = "Jornalismo"
    POPULAR = "Popular"
    SERTANEJO = "Sertanejo"
    GOSPEL = "Gospel"
    ROCK = "Rock"
    POP = "Pop"
    ELETRONICA = "Eletr칪nica"
    CLASSICA = "Cl치ssica"
    JAZZ = "Jazz"
    REGGAE = "Reggae"
    FUNK = "Funk"
    RAP = "Rap"
    FORRO = "Forr칩"
    MPB = "MPB"
    INTERNACIONAL = "Internacional"
    TALK_SHOW = "Talk Show"
    ESPORTIVA = "Esportiva"
    EDUCATIVA = "Educativa"

class RegiaoEnum(str, Enum):
    NORTE = "Norte"
    NORDESTE = "Nordeste"
    CENTRO_OESTE = "Centro-Oeste"
    SUDESTE = "Sudeste"
    SUL = "Sul"

# Models
class RedesSociais(BaseModel):
    facebook: Optional[str] = None
    instagram: Optional[str] = None
    tiktok: Optional[str] = None
    twitter: Optional[str] = None
    youtube: Optional[str] = None
    website: Optional[str] = None

class RadioStation(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    nome: str
    descricao: str
    stream_url: str
    genero: GeneroEnum
    regiao: RegiaoEnum
    cidade: str
    estado: str
    endereco: Optional[str] = None
    telefone: Optional[str] = None
    redes_sociais: Optional[RedesSociais] = None
    logo_url: Optional[str] = None
    data_cadastro: datetime = Field(default_factory=datetime.utcnow)
    ativo: bool = True

class RadioStationCreate(BaseModel):
    nome: str
    descricao: str
    stream_url: str
    genero: GeneroEnum
    regiao: RegiaoEnum
    cidade: str
    estado: str
    endereco: Optional[str] = None
    telefone: Optional[str] = None
    redes_sociais: Optional[RedesSociais] = None

class RadioStationUpdate(BaseModel):
    nome: Optional[str] = None
    descricao: Optional[str] = None
    stream_url: Optional[str] = None
    genero: Optional[GeneroEnum] = None
    regiao: Optional[RegiaoEnum] = None
    cidade: Optional[str] = None
    estado: Optional[str] = None
    endereco: Optional[str] = None
    telefone: Optional[str] = None
    redes_sociais: Optional[RedesSociais] = None
    ativo: Optional[bool] = None

class RadioFilters(BaseModel):
    busca: Optional[str] = None
    genero: Optional[GeneroEnum] = None
    regiao: Optional[RegiaoEnum] = None
    cidade: Optional[str] = None
    estado: Optional[str] = None
    ativo: Optional[bool] = True

# Customization Models
class ThemeColors(BaseModel):
    primary: str = "#06B6D4"
    secondary: str = "#0891B2"
    accent: str = "#2563EB"
    background: str = "#F8FAFC"
    text: str = "#1F2937"

class PlatformTexts(BaseModel):
    platform_name: str = "mobinabert PLAY"
    platform_slogan: str = "Descubra e ou칞a as melhores r치dios do Brasil em um s칩 lugar"
    hero_title: str = "游꿚 mobinabert PLAY"
    hero_subtitle: str = "Descubra e ou칞a as melhores r치dios do Brasil em um s칩 lugar"
    footer_text: str = "춸 2025 mobinabert PLAY - Todos os direitos reservados"

class PlatformCustomization(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    colors: ThemeColors = Field(default_factory=ThemeColors)
    texts: PlatformTexts = Field(default_factory=PlatformTexts)
    logo_url: Optional[str] = None
    favicon_url: Optional[str] = None
    theme_name: str = "default"
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
    active: bool = True

class CustomizationUpdate(BaseModel):
    colors: Optional[ThemeColors] = None
    texts: Optional[PlatformTexts] = None
    logo_url: Optional[str] = None
    favicon_url: Optional[str] = None
    theme_name: Optional[str] = None

# Authentication helper
async def verify_admin_token(credentials: HTTPAuthorizationCredentials = Depends(security)):
    if credentials.credentials != ADMIN_TOKEN:
        raise HTTPException(status_code=401, detail="Token inv치lido")
    return credentials.credentials

# Radio Routes
@api_router.get("/")
async def root():
    return {"message": "API da mobinabert PLAY - Plataforma de R치dios Online", "version": "1.0.0"}

@api_router.get("/radios", response_model=List[RadioStation])
async def get_radios(
    busca: Optional[str] = Query(None, description="Buscar por nome, cidade ou estado"),
    genero: Optional[GeneroEnum] = Query(None, description="Filtrar por g칡nero"),
    regiao: Optional[RegiaoEnum] = Query(None, description="Filtrar por regi칚o"),
    cidade: Optional[str] = Query(None, description="Filtrar por cidade"),
    estado: Optional[str] = Query(None, description="Filtrar por estado"),
    ativo: Optional[bool] = Query(True, description="Filtrar por status ativo"),
    limite: int = Query(50, ge=1, le=100, description="Limite de resultados"),
    pagina: int = Query(1, ge=1, description="P치gina")
):
    """Buscar r치dios com filtros"""
    
    # Construir filtros do MongoDB
    filtros = {}
    
    if ativo is not None:
        filtros["ativo"] = ativo
    
    if genero:
        filtros["genero"] = genero
    
    if regiao:
        filtros["regiao"] = regiao
    
    if cidade:
        filtros["cidade"] = {"$regex": cidade, "$options": "i"}
    
    if estado:
        filtros["estado"] = {"$regex": estado, "$options": "i"}
    
    # Busca textual
    if busca:
        filtros["$or"] = [
            {"nome": {"$regex": busca, "$options": "i"}},
            {"cidade": {"$regex": busca, "$options": "i"}},
            {"estado": {"$regex": busca, "$options": "i"}},
            {"descricao": {"$regex": busca, "$options": "i"}}
        ]
    
    # Pagina칞칚o
    skip = (pagina - 1) * limite
    
    # Buscar no banco
    radios = await db.radios.find(filtros).skip(skip).limit(limite).to_list(length=limite)
    
    return [RadioStation(**radio) for radio in radios]

@api_router.get("/radios/{radio_id}", response_model=RadioStation)
async def get_radio(radio_id: str):
    """Buscar r치dio por ID"""
    radio = await db.radios.find_one({"id": radio_id})
    if not radio:
        raise HTTPException(status_code=404, detail="R치dio n칚o encontrada")
    return RadioStation(**radio)

@api_router.post("/radios", response_model=RadioStation)
async def create_radio(radio_data: RadioStationCreate, _: str = Depends(verify_admin_token)):
    """Criar nova r치dio (requer autentica칞칚o admin)"""
    radio = RadioStation(**radio_data.dict())
    
    # Verificar se nome j치 existe
    existing = await db.radios.find_one({"nome": radio.nome})
    if existing:
        raise HTTPException(status_code=400, detail="J치 existe uma r치dio com este nome")
    
    await db.radios.insert_one(radio.dict())
    return radio

@api_router.put("/radios/{radio_id}", response_model=RadioStation)
async def update_radio(radio_id: str, radio_data: RadioStationUpdate, _: str = Depends(verify_admin_token)):
    """Atualizar r치dio (requer autentica칞칚o admin)"""
    
    # Verificar se existe
    existing = await db.radios.find_one({"id": radio_id})
    if not existing:
        raise HTTPException(status_code=404, detail="R치dio n칚o encontrada")
    
    # Atualizar apenas campos fornecidos
    update_data = {k: v for k, v in radio_data.dict().items() if v is not None}
    
    if update_data:
        await db.radios.update_one({"id": radio_id}, {"$set": update_data})
    
    # Retornar atualizado
    updated_radio = await db.radios.find_one({"id": radio_id})
    return RadioStation(**updated_radio)

@api_router.delete("/radios/{radio_id}")
async def delete_radio(radio_id: str, _: str = Depends(verify_admin_token)):
    """Deletar r치dio (requer autentica칞칚o admin)"""
    
    result = await db.radios.delete_one({"id": radio_id})
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="R치dio n칚o encontrada")
    
    return {"message": "R치dio deletada com sucesso"}

@api_router.post("/upload/logo/{radio_id}")
async def upload_logo(radio_id: str, file: UploadFile = File(...), _: str = Depends(verify_admin_token)):
    """Upload de logo para r치dio"""
    
    # Verificar se r치dio existe
    radio = await db.radios.find_one({"id": radio_id})
    if not radio:
        raise HTTPException(status_code=404, detail="R치dio n칚o encontrada")
    
    # Verificar tipo de arquivo
    if not file.content_type.startswith("image/"):
        raise HTTPException(status_code=400, detail="Apenas imagens s칚o permitidas")
    
    # Gerar nome 칰nico para o arquivo
    file_extension = file.filename.split(".")[-1]
    unique_filename = f"{radio_id}_{uuid.uuid4()}.{file_extension}"
    file_path = uploads_dir / unique_filename
    
    # Salvar arquivo
    async with aiofiles.open(file_path, 'wb') as out_file:
        content = await file.read()
        await out_file.write(content)
    
    # Atualizar URL do logo no banco
    logo_url = f"/uploads/{unique_filename}"
    await db.radios.update_one(
        {"id": radio_id}, 
        {"$set": {"logo_url": logo_url}}
    )
    
    return {"message": "Logo atualizado com sucesso", "logo_url": logo_url}

# Customization Routes
@api_router.get("/customization", response_model=PlatformCustomization)
async def get_customization():
    """Buscar configura칞칫es de customiza칞칚o ativas"""
    customization = await db.customization.find_one({"active": True})
    if not customization:
        # Criar configura칞칚o padr칚o se n칚o existir
        default_config = PlatformCustomization()
        await db.customization.insert_one(default_config.dict())
        return default_config
    return PlatformCustomization(**customization)

@api_router.put("/customization", response_model=PlatformCustomization)
async def update_customization(
    customization_data: CustomizationUpdate, 
    _: str = Depends(verify_admin_token)
):
    """Atualizar configura칞칫es de customiza칞칚o (requer autentica칞칚o admin)"""
    
    # Buscar configura칞칚o ativa
    existing = await db.customization.find_one({"active": True})
    if not existing:
        # Criar nova se n칚o existir
        new_config = PlatformCustomization()
        await db.customization.insert_one(new_config.dict())
        existing = new_config.dict()
    
    # Atualizar campos fornecidos
    update_data = {k: v for k, v in customization_data.dict().items() if v is not None}
    update_data["updated_at"] = datetime.utcnow()
    
    if update_data:
        await db.customization.update_one(
            {"active": True}, 
            {"$set": update_data}
        )
    
    # Retornar configura칞칚o atualizada
    updated_config = await db.customization.find_one({"active": True})
    return PlatformCustomization(**updated_config)

@api_router.post("/customization/logo")
async def upload_platform_logo(
    file: UploadFile = File(...), 
    _: str = Depends(verify_admin_token)
):
    """Upload de logo da plataforma"""
    
    # Verificar tipo de arquivo
    if not file.content_type.startswith("image/"):
        raise HTTPException(status_code=400, detail="Apenas imagens s칚o permitidas")
    
    # Gerar nome 칰nico para o arquivo
    file_extension = file.filename.split(".")[-1]
    unique_filename = f"platform_logo_{uuid.uuid4()}.{file_extension}"
    file_path = uploads_dir / unique_filename
    
    # Salvar arquivo
    async with aiofiles.open(file_path, 'wb') as out_file:
        content = await file.read()
        await out_file.write(content)
    
    # Atualizar URL do logo na configura칞칚o
    logo_url = f"/uploads/{unique_filename}"
    await db.customization.update_one(
        {"active": True}, 
        {"$set": {"logo_url": logo_url, "updated_at": datetime.utcnow()}}
    )
    
    return {"message": "Logo da plataforma atualizado com sucesso", "logo_url": logo_url}

@api_router.post("/customization/reset")
async def reset_customization(_: str = Depends(verify_admin_token)):
    """Resetar configura칞칫es para padr칚o"""
    
    # Desativar configura칞칚o atual
    await db.customization.update_many({"active": True}, {"$set": {"active": False}})
    
    # Criar nova configura칞칚o padr칚o
    default_config = PlatformCustomization()
    await db.customization.insert_one(default_config.dict())
    
    return {"message": "Configura칞칫es resetadas para padr칚o", "customization": default_config}

# Other Routes
@api_router.get("/generos")
async def get_generos():
    """Listar todos os g칡neros dispon칤veis"""
    return [{"value": genero.value, "label": genero.value} for genero in GeneroEnum]

@api_router.get("/regioes")
async def get_regioes():
    """Listar todas as regi칫es dispon칤veis"""
    return [{"value": regiao.value, "label": regiao.value} for regiao in RegiaoEnum]

@api_router.get("/cidades")
async def get_cidades():
    """Listar todas as cidades cadastradas"""
    cidades = await db.radios.distinct("cidade")
    return sorted(cidades)

@api_router.get("/estados")
async def get_estados():
    """Listar todos os estados cadastrados"""
    estados = await db.radios.distinct("estado")
    return sorted(estados)

@api_router.get("/stats")
async def get_stats():
    """Estat칤sticas da plataforma"""
    total_radios = await db.radios.count_documents({"ativo": True})
    
    # Contagem por g칡nero
    generos = await db.radios.aggregate([
        {"$match": {"ativo": True}},
        {"$group": {"_id": "$genero", "count": {"$sum": 1}}},
        {"$sort": {"count": -1}}
    ]).to_list(length=None)
    
    # Contagem por regi칚o
    regioes = await db.radios.aggregate([
        {"$match": {"ativo": True}},
        {"$group": {"_id": "$regiao", "count": {"$sum": 1}}},
        {"$sort": {"count": -1}}
    ]).to_list(length=None)
    
    return {
        "total_radios": total_radios,
        "por_genero": generos,
        "por_regiao": regioes
    }

# Include the router in the main app
app.include_router(api_router)

# CORS configuration
app.add_middleware(
    CORSMiddleware,
    allow_credentials=True,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

@app.on_event("shutdown")
async def shutdown_db_client():
    client.close()

# Health check
@app.get("/health")
async def health_check():
    return {"status": "healthy", "timestamp": datetime.utcnow()}